# 加密方法

```java
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.DigestUtils;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.*;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

@Slf4j
public class EncryptUtil {

    public static final String RSA = "RSA";
    public static final String AES = "AES";
    public static final String DES = "DES";
    public static final String BASE_64 = "base64";
    public static final String HEX = "hex";

    private EncryptUtil() {
        throw new IllegalStateException("Utility class");
    }

    /**
     * 加密算法枚举
     * 日志信息
     */
    @Getter
    public enum EncryptEnum {

        MD5("MD5", "EncryptUtil.md5(data)", "参数说明\n data：待签名内容"),
        SHA_1("SHA1 加密", "EncryptUtil.sha1(data)", "参数说明\n data：待签名内容"),
        SHA_256("SHA256 加密", "EncryptUtil.sha256(data)", "参数说明\n data：待签名内容"),
        RSA_SHA_1("RSA-SHA1 签名", "EncryptUtil.rsaSHA1(data,privateKey,\"base64\")", "参数说明\n data：待签名内容\n privateKey：密钥\n outputEncoding：结果的编码格式，base64(默认)/hex"),
        RSA_SHA_256("RSA-SHA256 签名", "EncryptUtil.rsaSHA256(data,privateKey,\"base64\")", "参数说明\n data：待签名内容\n privateKey：密钥\n outputEncoding：结果的编码格式，base64(默认)/hex"),
        RSA_PUBLIC_ENCRYPT("RSA 公钥加密", "EncryptUtil.rsaPublicEncrypt(publicKey,data,\"base64\")", "参数说明\n publicKey：公钥\n data：待加密内容\n outputEncoding：结果的编码格式,base64(默认)/hex"),
        RSA_PUBLIC_DECRYPT("RSA 公钥解密", "EncryptUtil.rsaPublicDecrypt(publicKey,data,\"base64\")", "参数说明\n publicKey：公钥\n data：待解密内容\n inputEncoding：待解密内容的编码格式,base64(默认)/hex"),
        RSA_PRIVATE_ENCRYPT("RSA 私钥加密", "EncryptUtil.rsaPrivateEncrypt(privateKey,data,\"base64\")", "参数说明\n privateKey：私钥\n data：待加密内容\n outputEncoding：结果的编码格式,base64(默认)/hex"),
        RSA_PRIVATE_DECRYPT("RSA 私钥解密", "EncryptUtil.rsaPrivateDecrypt(privateKey,data,\"base64\")", "参数说明\n privateKey：私钥\n data：待解密内容\n inputEncoding：待解密内容的编码格式,base64(默认)/hex"),
        AES_ENCRYPT("AES 加密", "EncryptUtil.aesEncrypt(data,password)", "参数说明\n data：待加密内容\n password：加密密码"),
        AES_DECRYPT("AES 解密", "EncryptUtil.aesDecrypt(data,password))", "参数说明\n data：待解密内容\n password：解密密码"),
        DES_ENCRYPT("DES 加密", "EncryptUtil.desEncrypt(data,password))", "参数说明\n data：待加密内容\n password：加密密码"),
        DES_DECRYPT("DES 解密", "EncryptUtil.desDecrypt(data,password))", "参数说明\n data：待解密内容\n password：解密密码"),
        LOG("日志信息", "log(data)", "参数说明\n data：日志数据");

        private String key;
        private String value;
        private String desc;

        EncryptEnum(String key, String value, String desc) {
            this.key = key;
            this.value = value;
            this.desc = desc;
        }
    }

    public static String md5(String data) {
        return DigestUtils.md5DigestAsHex(data.getBytes());
    }

    public static String sha1(String data) {
        try {
            MessageDigest messageDigest = MessageDigest.getInstance("SHA");
            byte[] cipherBytes = messageDigest.digest(data.getBytes(StandardCharsets.UTF_8));
            return parseByte2HexStr(cipherBytes);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String sha256(String data) {
        try {
            MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
            messageDigest.update(data.getBytes(StandardCharsets.UTF_8));
            byte[] bytes = messageDigest.digest();
            return parseByte2HexStr(bytes);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return null;
    }


    public static String rsaSHA1(String data, String privateKey, String outputEncoding) {
        try {
            byte[] keyBytes = Base64.getDecoder().decode(privateKey.getBytes());
            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
            PrivateKey priKey = KeyFactory.getInstance(RSA).generatePrivate(keySpec);
            Signature signature = Signature.getInstance("SHA1withRSA");
            signature.initSign(priKey);
            signature.update(data.getBytes(StandardCharsets.UTF_8));
            byte[] signs = signature.sign();
            if (BASE_64.equals(outputEncoding)) {
                return Base64.getEncoder().encodeToString(signs);
            }
            return parseByte2HexStr(signs);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }


    public static String rsaSHA256(String data, String privateKey, String outputEncoding) {
        try {
            byte[] keyBytes = Base64.getDecoder().decode(privateKey.getBytes());
            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
            PrivateKey priKey = KeyFactory.getInstance(RSA).generatePrivate(keySpec);
            Signature signature = Signature.getInstance("SHA256withRSA");
            signature.initSign(priKey);
            signature.update(data.getBytes(StandardCharsets.UTF_8));
            byte[] signs = signature.sign();
            if (BASE_64.equals(outputEncoding)) {
                return Base64.getEncoder().encodeToString(signs);
            }
            return parseByte2HexStr(signs);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String rsaPublicEncrypt(String publicKey, String data, String outputEncoding) {
        try {
            KeyFactory keyFactory = KeyFactory.getInstance(RSA);
            X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(Base64.getDecoder().decode(publicKey));
            RSAPublicKey key = (RSAPublicKey) keyFactory.generatePublic(x509KeySpec);
            Cipher cipher = Cipher.getInstance(RSA);
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] bytes = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));
            if (BASE_64.equals(outputEncoding)) {
                return Base64.getEncoder().encodeToString(bytes);
            }
            return parseByte2HexStr(bytes);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String rsaPublicDecrypt(String publicKey, String data, String inputEncoding) {
        try {
            byte[] dataBytes;
            if (BASE_64.equals(inputEncoding)) {
                dataBytes = Base64.getDecoder().decode(data);
            } else {
                dataBytes = parseHexStr2Byte(data);
            }

            KeyFactory keyFactory = KeyFactory.getInstance(RSA);
            X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(Base64.getDecoder().decode(publicKey));
            RSAPublicKey key = (RSAPublicKey) keyFactory.generatePublic(x509KeySpec);
            Cipher cipher = Cipher.getInstance(RSA);
            cipher.init(Cipher.DECRYPT_MODE, key);
            return new String(cipher.doFinal(dataBytes));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String rsaPrivateEncrypt(String privateKey, String data, String outputEncoding) {
        try {
            KeyFactory keyFactory = KeyFactory.getInstance(RSA);
            PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(privateKey));
            RSAPrivateKey key = (RSAPrivateKey) keyFactory.generatePrivate(pkcs8KeySpec);
            Cipher cipher = Cipher.getInstance(RSA);
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] bytes = cipher.doFinal(data.getBytes());
            if (BASE_64.equals(outputEncoding)) {
                return Base64.getEncoder().encodeToString(bytes);
            }
            return parseByte2HexStr(bytes);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String rsaPrivateDecrypt(String privateKey, String data, String inputEncoding) {
        try {
            byte[] dataBytes;
            if (BASE_64.equals(inputEncoding)) {
                dataBytes = Base64.getDecoder().decode(data);
            } else {
                dataBytes = parseHexStr2Byte(data);
            }
            KeyFactory keyFactory = KeyFactory.getInstance(RSA);
            PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(privateKey));
            RSAPrivateKey key = (RSAPrivateKey) keyFactory.generatePrivate(pkcs8KeySpec);
            Cipher cipher = Cipher.getInstance(RSA);
            cipher.init(Cipher.DECRYPT_MODE, key);
            return new String(cipher.doFinal(dataBytes));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String aesEncrypt(String data, String password) {
        try {
            KeyGenerator kgen = KeyGenerator.getInstance(AES);
            SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
            random.setSeed(password.getBytes());
            kgen.init(128, random);
            Cipher cipher = Cipher.getInstance(AES);
            cipher.init(Cipher.ENCRYPT_MODE, kgen.generateKey());
            return Base64.getEncoder().encodeToString(cipher.doFinal(data.getBytes()));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String aesDecrypt(String data, String password) {
        try {
            KeyGenerator kgen = KeyGenerator.getInstance(AES);
            SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
            random.setSeed(password.getBytes());
            kgen.init(128, random);
            Cipher cipher = Cipher.getInstance(AES);
            cipher.init(Cipher.DECRYPT_MODE, kgen.generateKey());
            return new String(cipher.doFinal(Base64.getDecoder().decode(data)));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String desEncrypt(String data, String password) {
        try {
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);
            Cipher cipher = Cipher.getInstance(DES);
            cipher.init(Cipher.ENCRYPT_MODE, keyFactory.generateSecret(new DESKeySpec(password.getBytes())), new SecureRandom());
            return Base64.getEncoder().encodeToString(cipher.doFinal(data.getBytes()));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String desDecrypt(String data, String password) {
        try {
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);
            Cipher cipher = Cipher.getInstance(DES);
            cipher.init(Cipher.DECRYPT_MODE, keyFactory.generateSecret(new DESKeySpec(password.getBytes())), new SecureRandom());
            return new String(cipher.doFinal(Base64.getDecoder().decode(data.getBytes())));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String parseByte2HexStr(byte[] buf) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < buf.length; i++) {
            String hex = Integer.toHexString(buf[i] & 0xFF);
            if (hex.length() == 1) {
                hex = '0' + hex;
            }
            sb.append(hex.toUpperCase());
        }
        return sb.toString();
    }

    public static byte[] parseHexStr2Byte(String hexStr) {
        if (hexStr.length() < 1) {
            return new byte[0];
        }
        byte[] result = new byte[hexStr.length() / 2];
        for (int i = 0; i < hexStr.length() / 2; i++) {
            int high = Integer.parseInt(hexStr.substring(i * 2, i * 2 + 1), 16);
            int low = Integer.parseInt(hexStr.substring(i * 2 + 1, i * 2 + 2), 16);
            result[i] = (byte) (high * 16 + low);
        }
        return result;
    }

    private static boolean verifyWhenSha1Sign(String content, String sign, PublicKey publicKey, String inputEncoding) {
        try {
            byte[] contentBytes = content.getBytes(StandardCharsets.UTF_8);
            Signature signature = Signature.getInstance("SHA1withRSA");
            signature.initVerify(publicKey);
            signature.update(contentBytes);
            if (BASE_64.equals(inputEncoding)) {
                return signature.verify(Base64.getDecoder().decode(sign));
            }
            return signature.verify(parseHexStr2Byte(sign));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

    private static boolean verifyWhenSha256Sign(String content, String sign, PublicKey publicKey, String inputEncoding) {
        try {
            byte[] contentBytes = content.getBytes(StandardCharsets.UTF_8);
            Signature signature = Signature.getInstance("SHA256withRSA");
            signature.initVerify(publicKey);
            signature.update(contentBytes);
            if (BASE_64.equals(inputEncoding)) {
                return signature.verify(Base64.getDecoder().decode(sign));
            }
            return signature.verify(parseHexStr2Byte(sign));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }

//    public static void main(String[] args) throws Exception {
//        String data = "678167910;7CPwqdWssdJqRvYXuobQC8cFJNKzb2zuSpUpWU2wWO8ro02hzHVBumi6P2s1EGiI;1618301195549;HZSAKRXW;";
//        String password = "aaaaaaaaasss2829:$";
//        //MD5
//        Assert.isTrue("d659425877f649d9e41dbab0faa9fee2".equalsIgnoreCase(md5(data)));
//        //sha1
//        Assert.isTrue("01cbad3ed9fcd28854adb4d63dbed4372a754a1b".equalsIgnoreCase(sha1(data)));
//        //sha256
//        Assert.isTrue("a40df75b1068c69be7dde0df699fff4bea5f7c1caa664558599b116a1af04dbc".equalsIgnoreCase(sha256(data)));
//
//        //创建rsa公钥私钥
//        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(RSA);
//        KeyPair keyPair = keyGen.generateKeyPair();
//        PublicKey publicKey = keyPair.getPublic();
//        PrivateKey privateKey = keyPair.getPrivate();
//        String privateKeyStr = new String(Base64.getEncoder().encode(privateKey.getEncoded()), StandardCharsets.UTF_8);
//        String publicKeyStr = new String(Base64.getEncoder().encode(publicKey.getEncoded()), StandardCharsets.UTF_8);
//
//        //sh1签名
//        String sha1Sign = rsaSHA1(data, privateKeyStr, BASE_64);
//        Assert.isTrue(verifyWhenSha1Sign(data, sha1Sign, publicKey, BASE_64));
//
//        //sh256签名
//        String sha256Sign = rsaSHA256(data, privateKeyStr, BASE_64);
//        Assert.isTrue(verifyWhenSha256Sign(data, sha256Sign, publicKey, BASE_64));
//
//        //aes加解密
//        Assert.isTrue(data.equalsIgnoreCase(aesDecrypt(aesEncrypt(data, password), password)));
//
//        //des加解密
//        Assert.isTrue(data.equalsIgnoreCase(desDecrypt(desEncrypt(data, password), password)));
//
//        //公钥加密私钥解密开始
//        String pass = rsaPublicEncrypt(publicKeyStr, data, BASE_64);
//        String dePass2 = rsaPrivateDecrypt(privateKeyStr, pass, BASE_64);
//        Assert.isTrue(data.equalsIgnoreCase(dePass2));
//
//        //私钥加密公钥解密开始
//        String pass2 = rsaPrivateEncrypt(privateKeyStr, data, BASE_64);
//        String dePass = rsaPublicDecrypt(publicKeyStr, pass2, BASE_64);
//        Assert.isTrue(data.equalsIgnoreCase(dePass));
//
//        //sh1签名 hex
//        String sha1Signhex = rsaSHA1(data, privateKeyStr, HEX);
//        Assert.isTrue(verifyWhenSha1Sign(data, sha1Signhex, publicKey, HEX));
//
//        //sh256签名 hex
//        String sha256Signhex = rsaSHA256(data, privateKeyStr, HEX);
//        Assert.isTrue(verifyWhenSha256Sign(data, sha256Signhex, publicKey, HEX));
//
//        //公钥加密私钥解密开始 hex
//        String passhex = rsaPublicEncrypt(publicKeyStr, data, HEX);
//        String dePass2hex = rsaPrivateDecrypt(privateKeyStr, passhex, HEX);
//        Assert.isTrue(data.equalsIgnoreCase(dePass2hex));
//
//        //私钥加密公钥解密开始 hex
//        String pass2hex = rsaPrivateEncrypt(privateKeyStr, data, HEX);
//        String dePasshex = rsaPublicDecrypt(publicKeyStr, pass2hex, HEX);
//        Assert.isTrue(data.equalsIgnoreCase(dePasshex));
//    }
}
```

