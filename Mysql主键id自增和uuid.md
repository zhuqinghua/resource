### Mysql主键id自增和uuid

- MyISAM 默认对字符串使用压缩索引，这会导致查询慢很多。
- innodb 中的主键是聚簇索引，会把相邻主键的数据安放在相邻的物理存储上。如果主键不是自增，而是随机的，那么频繁的插入会使 innodb 频繁地移动磁盘块，而影响IO性能

- 字符串值会任意分布在很大的空间内，这会导致 `INSERT` 以及一些 `SELECT` 语句变得很慢

  1. 插入值会随机地写到索引的不同位置，所以使得 `INSERT` 语句更慢。这会导致页分裂、磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片。
  2. `SELECT` 语句会变得更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。
  3. 随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的局部访问性原理失效。如果真个数据集都一样的“热”，那么缓存任何一部分特别数据到内存都没有好处；如果工作集比内存大，缓存将会有很多刷新和不命中。


> 1. uuid是无序的， 插入数据时，页的位置会发生变化，页分裂，速度慢。
> 2. uuid占的空间大，并且innodb中，别的索引还都要包含主键的值，那么每个索引的空间也都会增大，占的空间大，需要读数据时一般会认为需要的io次数多。
> 3. uuid应该移除 “-” 符号；更好的做法是，使用 `UNHEX()` 函数转换 UUID 值为 16 字节的数字，并且存储在一个 `BINARY(16)` 列中。检索时可以通过 `HEX()`函数来格式化为十六进制格式

链接：https://www.zhihu.com/question/43500172

​           https://cloud.tencent.com/developer/article/1184708



### 范式

1NF的定义为：符合1NF的关系中的每个属性都不可再分

 2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖**。 函数依赖，码，非主属性，部分函数依赖

3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖

BCNF在3NF 的基础上消除**主属性**对于码的部分与传递函数依赖

> 一范式就是属性不可分割
>
> 二范式就是要有主键，要求其他字段都依赖于主键
>
> 三范式就是要消除传递依赖，方便理解，可以看做是“消除冗余”

总结：
1NF： 字段是最小的的单元不可再分
2NF：满足1NF,表中的字段必须完全依赖于全部主键而非部分主键 (一般我们都会做到)
3NF：满足2NF,非主键外的所有字段必须互不依赖
4NF：满足3NF,消除表中的多值依赖